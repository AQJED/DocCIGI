<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A Comprehensive Guide to Converting DIS to CIGI</title>
  <style>
    /* Base Resets */
    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #ffffff;
      color: #333;
    }
    /* Sidebar Styling */
    .sidebar {
      background-color: #f4f4f4;
      width: 250px;
      padding: 20px;
      position: fixed;
      height: 100%;
      overflow-y: auto;
      box-sizing: border-box;
      border-right: 1px solid #ddd;
    }
    .sidebar .brand {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .sidebar .version {
      font-size: 0.75rem;
      color: #999;
    }
    .search-box {
      width: 100%;
      padding: 8px;
      margin-bottom: 20px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .nav-links a {
      display: block;
      color: #333;
      text-decoration: none;
      padding: 8px 0;
      border-bottom: 1px solid #ddd;
    }
    .nav-links a:hover {
      background-color: #eaeaea;
    }
    /* Main Content Styling */
    .content {
      margin-left: 270px; /* Sidebar width plus margin */
      padding: 20px;
      max-width: 900px;
      box-sizing: border-box;
    }
    .breadcrumb {
      font-size: 0.875rem;
      margin-bottom: 10px;
      color: #666;
    }
    .page-title {
      font-size: 2rem;
      margin-bottom: 10px;
      font-weight: bold;
    }
    .lead {
      font-size: 1.125rem;
      margin-bottom: 20px;
      color: #555;
    }
    .doc-section {
      margin-bottom: 40px;
    }
    .doc-section h2 {
      font-size: 1.75rem;
      margin-bottom: 10px;
      border-bottom: 2px solid #ddd;
      padding-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .doc-section h3 {
      font-size: 1.5rem;
      margin-top: 20px;
      margin-bottom: 10px;
    }
    .doc-section h4 {
      font-size: 1.25rem;
      margin-top: 15px;
      margin-bottom: 10px;
      color: #555;
    }
    /* Table Styling */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #f4f4f4;
      font-weight: bold;
    }
    tr:nth-child(even) {
      background-color: #fafafa;
    }
    /* Code Block Styling */
    pre {
      background-color: #2d2d2d;
      color: #f8f8f2;
      padding: 10px;
      overflow-x: auto;
      border-radius: 4px;
    }
    /* Footer Styling */
    .footer {
      text-align: center;
      font-size: 0.875rem;
      color: #777;
      margin-top: 40px;
      padding: 20px;
      border-top: 1px solid #ddd;
    }
    /* Responsive Adjustments */
    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
        position: relative;
        height: auto;
        border-right: none;
      }
      .content {
        margin-left: 0;
      }
    }
    /* Style for image figures */
    .image-banner figure {
      display: inline-block;
      margin-right: 10px;
      text-align: center;
    }
    .image-banner figure:last-child {
      margin-right: 0;
    }
    .image-banner img {
      max-width: 100%;
      height: auto;
    }
    .image-banner figcaption {
      font-size: 0.875rem;
      color: #555;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <!-- Sidebar Navigation -->
  <aside class="sidebar">
    <h1 class="brand">DIS-CIGI <span class="version">v1.0</span></h1>
    <input type="text" placeholder="Search articles..." class="search-box" />
    <nav class="nav-links">
      <a href="#introduction">Getting Started</a>
      <a href="#dis-protocol">DIS Protocol</a>
      <a href="#cigi-protocol">CIGI Protocol</a>
      <a href="#mapping">Mapping Strategy</a>
      <a href="#conversion">Conversion Flow</a>
      <a href="#best-practices">Best Practices</a>
    </nav>
  </aside>

  <!-- Main Content -->
  <main class="content">
    <div class="breadcrumb">Home</div>
    <h1 class="page-title" id="introduction">Getting Started</h1>
    <p class="lead">
      This guide focuses solely on converting DIS data into CIGI-compliant packets. It provides a detailed exploration of each protocol, practical mapping strategies, and data conversion techniques essential for seamless simulation interoperability.
    </p>

    <!-- DIS Protocol Section -->
    <section class="doc-section" id="dis-protocol">
      <h2>Understanding the DIS Protocol</h2>
      <p>
        DIS (Distributed Interactive Simulation) is used for exchanging simulation data such as entity states, movements, and interactions across distributed systems. The Entity State PDU, one of its key components, encapsulates detailed information about each simulation entity.
      </p>
      <!-- Insert the two png images with captions -->
      <div class="image-banner">
        <figure>
          <img src="CIGI.png" alt="A CIGI Package Sample Capture by Wireshark.">
	    <figcaption style="font-size: 1.2em; font-weight: bold;">A CIGI Package Sample Capture by Wireshark.</figcaption>
        </figure>
        <figure>
          <img src="DIS.png" alt="A DIS Package Sample Capture by Wireshark.">
          <figcaption style="font-size: 1.2em; font-weight: bold;">A DIS Package Sample Capture by Wireshark.</figcaption>
        </figure>
      </div>
      <h3>DIS Packet Structure: Detailed Field Breakdown</h3>
      <table>
         <thead>
           <tr>
             <th>Field Name</th>
             <th>Description</th>
             <th>OpenDIS Getter Function</th>
           </tr>
         </thead>
         <tbody>
           <tr>
             <td>Protocol Version</td>
             <td>Version of the DIS protocol used.</td>
             <td>getProtocolVersion()</td>
           </tr>
           <tr>
             <td>PDU Type</td>
             <td>Identifies the type of PDU (e.g., Entity State).</td>
             <td>getPduType()</td>
           </tr>
           <tr>
             <td>PDU Length</td>
             <td>Total length of the PDU in bytes.</td>
             <td>getLength()</td>
           </tr>
           <tr>
             <td>Timestamp</td>
             <td>Relative time of packet capture.</td>
             <td>getTimestamp()</td>
           </tr>
           <tr>
             <td>Entity ID (Composite)</td>
             <td>Combines Site ID, Application ID, and Entity ID to uniquely identify an entity.</td>
             <td>getEntityID() (returns object with getSite(), getApplication(), getEntity())</td>
           </tr>
           <tr>
             <td>Force ID</td>
             <td>Identifies the force affiliation (e.g., friendly, enemy).</td>
             <td>getForceId()</td>
           </tr>
           <tr>
             <td>Entity Type</td>
             <td>Specifies attributes such as country, domain, category, etc.</td>
             <td>getEntityType()</td>
           </tr>
           <tr>
             <td>Entity Appearance</td>
             <td>A 32-bit bitfield encoding visual flags, health, and other state parameters.</td>
             <td>getEntityAppearance()</td>
           </tr>
           <tr>
             <td>Entity Location (X, Y, Z)</td>
             <td>Location expressed in ECEF coordinates (X, Y, Z).</td>
             <td>getEntityLocation() (returns object with getX(), getY(), getZ())</td>
           </tr>
           <tr>
             <td>Entity Orientation</td>
             <td>Orientation represented by Euler angles in radians (Psi, Theta, Phi).</td>
             <td>getEntityOrientation() (returns object with getPsi(), getTheta(), getPhi())</td>
           </tr>
           <tr>
             <td>Linear Velocity (X, Y, Z)</td>
             <td>Velocity components in m/s.</td>
             <td>getEntityLinearVelocity() (returns object with getX(), getY(), getZ())</td>
           </tr>
           <tr>
             <td>Dead Reckoning Params</td>
             <td>Parameters used for extrapolating the entity’s future location and orientation.</td>
             <td>getDeadReckoningParameters()</td>
           </tr>
           <tr>
             <td>Marking</td>
             <td>ASCII string (up to 11 characters) used for identification.</td>
             <td>getMarking()</td>
           </tr>
           <tr>
             <td>Capabilities</td>
             <td>Bitmask representing the capabilities of the entity.</td>
             <td>getCapabilities()</td>
           </tr>
         </tbody>
      </table>
    </section>

    <!-- CIGI Protocol Section -->
    <section class="doc-section" id="cigi-protocol">
      <h2>Exploring the CIGI Protocol</h2>
      <p>
        CIGI (Common Image Generator Interface) is designed for sending real-time control data to image generators, ensuring that rendered visuals accurately reflect the simulation state. It operates on a frame-based update system.
      </p>
      <h3>CIGI Packet Structure: Detailed Field Breakdown</h3>
      <table>
         <thead>
           <tr>
             <th>Field Name</th>
             <th>Description</th>
             <th>CCL Setter Function</th>
           </tr>
         </thead>
         <tbody>
           <tr>
             <td>Packet ID</td>
             <td>Identifies the packet type (Entity Control).</td>
             <td>NA</td>
           </tr>
           <tr>
             <td>Packet Size</td>
             <td>Total size of the packet.</td>
             <td>NA</td>
           </tr>
           <tr>
             <td>Entity ID</td>
             <td>Unique 16-bit identifier for the entity.</td>
             <td>SetEntityID()</td>
           </tr>
           <tr>
             <td>Entity State</td>
             <td>Enumerated state indicating the lifecycle or activity of the entity.</td>
             <td>SetEntityState()</td>
           </tr>
           <tr>
             <td>Attach State</td>
             <td>Indicates whether the entity is attached or detached.</td>
             <td>SetAttachState()</td>
           </tr>
           <tr>
             <td>Collision Detection</td>
             <td>Flags for collision detection requests.</td>
             <td>SetCollisionDetectEn()</td>
           </tr>
           <tr>
             <td>Inherit Alpha</td>
             <td>Determines if the alpha (transparency) value is inherited.</td>
             <td>SetInheritAlpha()</td>
           </tr>
           <tr>
             <td>Ground/Ocean Clamp</td>
             <td>Determines if ground or ocean clamping is enabled.</td>
             <td>SetGrndClamp()</td>
           </tr>
           <tr>
             <td>Alpha</td>
             <td>Transparency value for the entity.</td>
             <td>SetAlpha()</td>
           </tr>
           <tr>
             <td>Reserved Byte</td>
             <td>Reserved field (typically set to zero).</td>
             <td>NA</td>
           </tr>
           <tr>
             <td>Entity Type</td>
             <td>Field representing the type of entity.</td>
             <td>SetEntityType()</td>
           </tr>
           <tr>
             <td>Parent ID</td>
             <td>Identifier for the parent entity (if any).</td>
             <td>SetParentID()</td>
           </tr>
           <tr>
             <td>Roll</td>
             <td>Rotation about the longitudinal axis, in degrees.</td>
             <td>SetRoll()</td>
           </tr>
           <tr>
             <td>Pitch</td>
             <td>Rotation about the lateral axis, in degrees.</td>
             <td>SetPitch()</td>
           </tr>
           <tr>
             <td>Yaw</td>
             <td>Rotation about the vertical axis, in degrees.</td>
             <td>SetYaw()</td>
           </tr>
           <tr>
             <td>Latitude</td>
             <td>Geodetic latitude in degrees.</td>
             <td>SetLat()</td>
           </tr>
           <tr>
             <td>Longitude</td>
             <td>Geodetic longitude in degrees.</td>
             <td>SetLon()</td>
           </tr>
           <tr>
             <td>Altitude</td>
             <td>Altitude in meters.</td>
             <td>SetAlt()</td>
           </tr>
         </tbody>
      </table>
    </section>

    <!-- Mapping Strategy Section -->
    <section class="doc-section" id="mapping">
      <h2>Mapping DIS to CIGI: Step-by-Step Conversion Process</h2>
      <p>
        Mapping a DIS packet to a CIGI packet requires careful handling of field definitions, data representations, and protocol design differences. The process is broken down into several key steps:
      </p>
      <h3>Challenges in Field Mapping</h3>
      <ul>
        <li>
          <strong>Composite vs. Simple Identifiers:</strong>
          DIS uses a composite 6-byte Entity Identifier made up of three 2-byte fields:
          <ul>
            <li>Site ID (uint16_t)</li>
            <li>Application ID (uint16_t)</li>
            <li>Entity ID (uint16_t)</li>
          </ul>
          This allows globally unique identification of entities across distributed simulation networks. CIGI, on the other hand, typically uses a single 16-bit (2-byte) Entity ID, which must be unique only within the scope of a connected session or scenario. This simplified format suits its local rendering role within the Image Generator (IG).
          <br><br>
          <table>
            <thead>
              <tr>
                <th>Protocol</th>
                <th>Field Breakdown</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>DIS</td>
                <td>Site ID (uint16_t)</td>
                <td>85</td>
              </tr>
              <tr>
                <td>DIS</td>
                <td>App ID (uint16_t)</td>
                <td>60</td>
              </tr>
              <tr>
                <td>DIS</td>
                <td>Entity ID (uint16_t)</td>
                <td>1001</td>
              </tr>
              <tr>
                <td>→ Composite ID</td>
                <td colspan="2">(85, 60, 1001)</td>
              </tr>
              <tr>
                <td>CIGI</td>
                <td>Entity ID (16-bit)</td>
                <td>1 (or any 16-bit mapped ID)</td>
              </tr>
            </tbody>
          </table>
          In this case, you may create a lookup table or mapping logic that assigns the DIS entity (85, 60, 1001) a corresponding CIGI Entity ID of 1.
        </li>
        <li><strong>Unit Conversion:</strong> Convert DIS orientations (radians) to CIGI degrees.</li>
        <li><strong>Coordinate Conversion:</strong> Convert ECEF coordinates (DIS) into geodetic coordinates (latitude, longitude, altitude) for CIGI.</li>
        <li><strong>Bitfield Extraction:</strong> Extract critical state information from DIS bitfields and map them to discrete CIGI enumerations.</li>
      </ul>
      <h3>Conversion Steps</h3>
      <ol>
        <li><strong>Extract Data:</strong> Use OpenDIS getters to retrieve each field from the DIS packet.</li>
        <li><strong>Data Conversions:</strong>
          <ul>
            <li>Convert composite DIS Entity IDs into a 16-bit CIGI ID.</li>
            <li>Transform Euler angles from radians to degrees.</li>
            <li>Convert ECEF coordinates to geodetic coordinates using an iterative algorithm or library.</li>
          </ul>
        </li>
        <li><strong>Map Appearance Bits:</strong> Extract specific bits (e.g., bits 22–23) from the DIS Appearance field and map to the corresponding CIGI state.</li>
        <li><strong>Assemble the CIGI Packet:</strong> Use CCL setters to populate the CIGI Entity Control packet.</li>
        <li><strong>Validation and Synchronization:</strong> Confirm all values are within acceptable ranges and maintain proper frame synchronization.</li>
      </ol>
      <h3>Entity Lifecycle Management</h3>
      <p>
        One key difference between the two protocols lies in entity lifecycle control. DIS broadcasts entity state continuously—meaning an entity “exists” as long as its state is being transmitted. In contrast, CIGI requires explicit management of entity states:
      </p>
      <ul>
        <li><strong>Spawning Entities:</strong> When a new DIS entity appears, issue a CIGI Entity Control packet with <code>SetEntityState(CigiBaseEntityCtrl::Active)</code>.</li>
        <li><strong>Updating Entities:</strong> As long as the entity remains present in DIS, send periodic updates with Active state.</li>
        <li><strong>Removing Entities:</strong> When an entity disappears from DIS or becomes inactive, send a <code>SetEntityState(CigiBaseEntityCtrl::Remove)</code> to explicitly remove it from the scene.</li>
      </ul>
      <p>
        Failing to manage this lifecycle can result in visual artifacts—such as “ghost” entities remaining visible on the Image Generator.
      </p>
      <h3>Use of Lookup Tables (Alternative Strategy)</h3>
      <p>
        In many real-world simulation environments, an alternative and often more efficient approach is to use explicit lookup tables to map DIS fields to predefined CIGI values. This is particularly helpful when the simulation environment is known in advance.
      </p>
      <ul>
        <li><strong>Example Use Cases:</strong> Mapping DIS entity types or appearance flags to corresponding CIGI database IDs, model types, or animation settings.</li>
        <li><strong>Advantages:</strong> Improves runtime efficiency, simplifies mapping logic, and provides deterministic behavior for entity rendering.</li>
        <li><strong>Use Case Dependency:</strong> In tightly controlled simulation systems (e.g., military aircraft or ground vehicles), this approach is not only easier but sometimes the only practical way to ensure correct CIGI behavior.</li>
      </ul>
    </section>

    <!-- Conversion Flow Section -->
    <section class="doc-section" id="conversion">
      <h2>Detailed Data Conversion and Velocity Handling</h2>
      <p>
        Data conversion is critical when mapping DIS packets to CIGI packets. It involves transforming field values to match the destination protocol's formats and handling movement data in a unique manner.
      </p>
      <h3>Field Value Conversions</h3>
      <p>
        <strong>Identifier Conversion:</strong> Convert composite DIS identifiers into a simple 16-bit value via truncation or remapping.<br>
        <strong>Orientation Conversion:</strong> Transform Euler angles from radians to degrees using the formula: <code>Degrees = Radians * (180/π)</code>.<br>
        <strong>Coordinate Conversion:</strong> Convert ECEF coordinates into geodetic coordinates (latitude, longitude, altitude) using an iterative algorithm or a conversion library such as GeographicLib.
      </p>
      <h3>Velocity Handling</h3>
      <p>
        DIS includes a velocity vector (X, Y, Z), but CIGI does not have a dedicated velocity field. Instead, CIGI relies on rapid updates of position and orientation. The Image Generator (IG) interprets movement by comparing successive frames—for example, if an entity’s position changes from <code>P1</code> at time <code>t</code> to <code>P2</code> at time <code>t+Δt</code>, the movement is derived from <code>P2 - P1</code>.
      </p>
      <h4>Debugging and Reverse Engineering Insights</h4>
      <p>
        To accurately map between protocols, reverse engineering played a vital role. Using Wireshark, CIGI packets were captured during known DIS events, such as spawning or firing. This allowed observation of:
      </p>
      <ul>
        <li>How CIGI represents multiple entities in one packet (e.g., aircraft and its fired munitions).</li>
        <li>Which specific setter values in the CIGI Class Library (CCL) are triggered in response to certain DIS events.</li>
      </ul>
      <p>
        From this, the mapping strategy was refined by referencing the CIGI Class Library (CCL) and OpenDIS side-by-side. DIS getters were used to extract data fields, and CIGI setters were then applied to build structured Entity Control packets.
      </p>
      <p>
        This reverse engineering approach filled in documentation gaps and confirmed expected behaviors on the Image Generator.
      </p>
      <h3>Consolidated Data Conversion Flow</h3>
      <p>
        1. Extract data from the DIS packet using OpenDIS getters.<br>
        2. Convert composite identifiers, orientations, and coordinates as described.<br>
        3. Omit direct velocity mapping – allow high-frequency updates to imply motion.<br>
        4. Assemble the CIGI packet using CCL setters.<br>
        5. Validate all values and ensure synchronization.
      </p>
    </section>

    <!-- Best Practices Section -->
    <section class="doc-section" id="best-practices">
      <h2>Conclusion and Best Practices</h2>
      <p>
        Mapping DIS to CIGI poses unique challenges due to differences in field definitions, measurement units, and update frequencies. A thorough understanding of both protocols and a methodical conversion process are essential for ensuring seamless simulation interoperability.
      </p>
      <h3>Best Practices</h3>
      <ul>
        <li>Document every conversion step – include OpenDIS getters and CCL setters.</li>
        <li>Validate data ranges, especially for positions and orientations.</li>
        <li>Optimize performance-critical tasks with efficient code (e.g., inline functions for coordinate conversion).</li>
        <li>Maintain comprehensive logging to facilitate debugging and error resolution.</li>
      </ul>
    </section>

    <footer class="footer">
      <p>© 2025 Adeeb Alqahtani. All rights reserved.</p>
    </footer>
  </main>
</body>
</html>
